"""Analyze existing result files without re-running the analysis."""
from pathlib import Path
from typing import List, Optional

import pandas as pd

from src.analysis.reporting.results import ResultsManager
from src.analysis.reporting.notebook_html import generate_notebook_html


class ResultAnalyzer:
    """Analyze existing result files without re-running the analysis."""
    
    def __init__(self, results_dir: Optional[str] = None):
        """
        Initialize ResultAnalyzer.
        
        Args:
            results_dir: Optional directory containing result files. If None, uses 'results' relative to project root.
        """
        self.manager = ResultsManager(output_dir=results_dir)
        self.results_dir = self.manager.output_dir
    
    def list_results(self, layer: Optional[int] = None, pattern: Optional[str] = None) -> List[Path]:
        """
        List available result files.
        
        Args:
            layer: Optional layer number to filter by
            pattern: Optional pattern to filter files (e.g., "layer10_*")
            
        Returns:
            List of result file paths, sorted by modification time (newest first)
        """
        if pattern:
            files = list(self.results_dir.glob(pattern))
        elif layer is not None:
            files = list(self.results_dir.glob(f"layer{layer}_*.json"))
        else:
            files = list(self.results_dir.glob("*.json"))
        
        return sorted(files, key=lambda p: p.stat().st_mtime, reverse=True)
    
    def load_and_analyze(
        self,
        result_files: List[str],
        generate_html: bool = True,
        generate_plots: bool = True,
        compare_runs: bool = True
    ) -> pd.DataFrame:
        """
        Load result files and generate all analysis outputs without re-running the analysis.
        
        Args:
            result_files: List of paths to result JSON files (or filenames relative to results dir)
            generate_html: Whether to generate HTML report
            generate_plots: Whether to generate diagnostic plots
            compare_runs: Whether to show comparison plots
            
        Returns:
            DataFrame with comparison results
        """
        # Resolve file paths
        resolved_files = []
        for f in result_files:
            f_path = Path(f)
            if not f_path.is_absolute():
                # Try relative to results directory
                potential_path = self.results_dir / f_path
                if potential_path.exists():
                    resolved_files.append(str(potential_path))
                elif f_path.exists():
                    resolved_files.append(str(f_path))
                else:
                    print(f"⚠️  Warning: File not found: {f}")
            else:
                resolved_files.append(f)
        
        if not resolved_files:
            raise ValueError("No valid result files found")
        
        print(f"Loading {len(resolved_files)} result file(s)...")
        print("=" * 60)
        
        # Load and compare results
        comparison_df = None
        if compare_runs:
            from src.analysis import compare_runs
            print("\nGenerating comparison plots...")
            comparison_df = compare_runs(resolved_files, show_plots=True, diagnostic=generate_plots)
        
        # Generate HTML report
        if generate_html:
            print("\nGenerating HTML report...")
            html_path = generate_notebook_html(
                resolved_files,
                include_diagnostic_plots=generate_plots
            )
            print(f"✓ HTML report: {html_path}")
        
        # Diagnostic plots are generated by compare_runs when diagnostic=True
        # No separate diagnostic plot generation needed
        
        return comparison_df
    
    def analyze_latest(self, layer: Optional[int] = None, **kwargs) -> pd.DataFrame:
        """
        Analyze the most recent result file(s) for a layer.
        
        Args:
            layer: Optional layer number. If None, uses most recent file across all layers.
            **kwargs: Additional arguments passed to load_and_analyze
            
        Returns:
            DataFrame with analysis results
        """
        files = self.list_results(layer=layer)
        
        if not files:
            if layer is not None:
                raise ValueError(f"No result files found for layer {layer}")
            else:
                raise ValueError("No result files found in results directory")
        
        # Use most recent file(s)
        result_file = str(files[0])
        print(f"Using most recent result file: {result_file}")
        
        return self.load_and_analyze([result_file], **kwargs)
    
    def analyze_all_layers(self, **kwargs) -> dict:
        """
        Analyze result files for all available layers.
        
        Args:
            **kwargs: Additional arguments passed to load_and_analyze
            
        Returns:
            Dictionary mapping layer numbers to DataFrames
        """
        all_files = self.list_results()
        
        # Group by layer
        by_layer = {}
        for f in all_files:
            # Extract layer from filename (format: layer{layer}_...)
            try:
                layer = int(f.stem.split('_')[0].replace('layer', ''))
                if layer not in by_layer:
                    by_layer[layer] = []
                by_layer[layer].append(str(f))
            except (ValueError, IndexError):
                continue
        
        results = {}
        for layer, files in sorted(by_layer.items()):
            print(f"\n{'='*60}")
            print(f"Analyzing Layer {layer} ({len(files)} file(s))")
            print('='*60)
            results[layer] = self.load_and_analyze(files, **kwargs)
        
        return results


def analyze_results(
    result_files: Optional[List[str]] = None,
    layer: Optional[int] = None,
    generate_html: bool = True,
    generate_plots: bool = True,
    compare_runs: bool = True
) -> pd.DataFrame:
    """
    Convenience function to analyze existing result files.
    
    Args:
        result_files: Optional list of result file paths. If None, uses most recent for layer.
        layer: Optional layer number to filter by
        generate_html: Whether to generate HTML report
        generate_plots: Whether to generate diagnostic plots
        compare_runs: Whether to show comparison plots
        
    Returns:
        DataFrame with analysis results
    """
    analyzer = ResultAnalyzer()
    
    if result_files is None:
        return analyzer.analyze_latest(
            layer=layer,
            generate_html=generate_html,
            generate_plots=generate_plots,
            compare_runs=compare_runs
        )
    else:
        return analyzer.load_and_analyze(
            result_files,
            generate_html=generate_html,
            generate_plots=generate_plots,
            compare_runs=compare_runs
        )

